////////////////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2020 xx network SEZC                                                       //
//                                                                                        //
// Use of this source code is governed by a license that can be found in the LICENSE file //
////////////////////////////////////////////////////////////////////////////////////////////

package wallet

import (
	"encoding/base64"
	"errors"
	"github.com/tyler-smith/go-bip39"
	"gitlab.com/xx_network/crypto/hasher"
	"gitlab.com/xx_network/crypto/wots"
	"io"
	"strings"
)

var (
	wotsParams = wots.DecodeParams(wots.DefaultParams)
	path, _ = NewPath(0, uint32(wots.DefaultParams), 0)
)

const EntropySize = 32
const MnemonicWords = 24

///////////////////////////////////////////////////////////////////////
// SLEEVE WALLET
/*
	Sleeve is a novel way of embedding a quantum secure key in the
	generation of curve based, non quantum secure keys
	Find out more about Sleeve at: xx.network/sleeve

	A complete diagram of the Sleeve wallet generation can be found
	in the docs folder. This implementation of Sleeve uses a WOTS+
	key as the underlying quantum secure key, and the diagram for
	the generation of this key can also bbe found in the docs folder.

	Essentially, the input for wallet generation is random entropy,
	which is encoded into a mnemonic phrase using BIP39. Then a BIP44
	custom path of m/44'/1955'/0'/0'/0' is used in a BIP32 derivation
	to generate a 256 bit child private key and 256 bit chain code.

	The private key and chain code are used, respectively, as the
	secret and public seeds in WOTS+ generation. After the WOTS+ key
	is generated, we save the quantum secure public key (PK).
	This public key will be used in as the Wallet address when full
	quantum secure capabilities are implemented in the future.

	The private key is also used to derive a "sleeve secret key".
	This secret key allows the WOTS+ public key to be safely shared
	at anytime, without compromising the non quantum secure keys
	generated by Sleeve. This secret key will be used in the future
	to redeem non quantum secure wallets into the WOTS+ quantum
	secure wallet.

	The sleeve output is generated using SHA3_256 to hash the
	sleeve private key and WOTS+ public key together. The resulting
	hash value is then encoded using BIP39, providing the output
	mnemonic, which can be used to generate non quantum secure keys
	on any blockchain platform.
*/
type Sleeve struct {
	// Sleeve mnemonic: used to recover a Sleeve wallet
	// User must store this safely for future use
	mnemonic  string
	// Quantum secure xx network wallet address (for future use)
	xxAddress string
	// Output mnemonic: used to generate/recover any non quantum secure wallets
	// User must store this safely, but in case of loss, it can be
	// regenerated from the Sleeve mnemonic
	output    string
}

///////////////////////////////////////////////////////////////////////
// CONSTRUCTORS

// Create a sleeve reading entropy from the provided CSPRNG and with the supplied passphrase
func NewSleeve(csprng io.Reader, passphrase string) (*Sleeve, error) {
	// 1. Read EntropySize bytes of entropy from csprng
	ent := make([]byte, EntropySize)
	if n, err := csprng.Read(ent); n != EntropySize || err != nil {
		return nil, errors.New("couldn't read enough bytes of entropy from provided reader")
	}

	// 2. Get sleeve from entropy
	return NewSleeveFromEntropy(ent, passphrase)
}

// Create a sleeve with provided entropy and passphrase
// Entropy must have 32 bytes
func NewSleeveFromEntropy(ent []byte, passphrase string) (*Sleeve, error) {
	// 1. Generate BIP39 mnemonic from entropy
	// (fails if entropy is not 16, 20, 24, 28 or 32 bytes)
	mnem, err := bip39.NewMnemonic(ent)
	if err != nil {
		return nil, err
	}

	// 2. Validate entropy has Sleeve required size of EntropySize
	if len(ent) != EntropySize {
		return nil, errors.New("provided entropy is of incorrect size")
	}

	// 3. Get Sleeve from mnemonic
	return NewSleeveFromMnemonic(mnem, passphrase)
}

// Create a sleeve with provided mneomonic and passphrase
// Mnemonic must be valid under BIP39 and have 24 words
func NewSleeveFromMnemonic(mnemonic, passphrase string) (*Sleeve, error) {
	// 1. Validate mnemonic has MnemonicWords words
	words := strings.Fields(mnemonic)

	if len(words) != MnemonicWords {
		return nil, errors.New("mnemonic has invalid number of words")
	}

	// 2. Generate sleeve (internally validates mnemonic)
	sl, err := generateSleeve(mnemonic, passphrase)
	if err != nil {
		return nil, err
	}

	return sl, nil
}

///////////////////////////////////////////////////////////////////////
// GETTERS

// Get the Sleeve's mnemonic
func (s *Sleeve) GetMnemonic() string {
	return s.mnemonic
}

// Get the quantum secure xx network wallet address
// NOTE: For future use only
func (s *Sleeve) GetXXAddress() string {
	return s.xxAddress
}

// Get the Sleeve's output mnemonic
func (s *Sleeve) GetOutputMnemonic() string {
	return s.output
}

///////////////////////////////////////////////////////////////////////
// PRIVATE

// Generate the sleeve according to the generation spec
// (diagram found in the docs folder)
func generateSleeve(mnemonic, passphrase string) (*Sleeve, error) {
	// 1. Generate seed from mnemonic (validates the mnemonic)
	seed, err := bip39.NewSeedWithErrorChecking(mnemonic, passphrase)
	if err != nil {
		return nil, err
	}

	// 2. Derive seeds using BIP32 and default path
	node, err := ComputeNode(seed, path)
	if err != nil {
		return nil, err
	}

	// 3. Generate WOTS+ key from seed and public seed
	wotsKey := wots.NewKeyFromSeed(wotsParams, node.Key, node.Code)

	// 4. Get WOTS+ Pubic Key and encode xx-address
	pk := wotsKey.ComputePK()
	xxAddress := "xx-" + base64.StdEncoding.EncodeToString(pk)

	// 5. Derive Sleeve secret key and output entropy
	secretKey := hasher.SHA3_256.Hash(append([]byte("xx network sleeve"), node.Key...))
	outEnt := hasher.SHA3_256.Hash(append(secretKey, pk...))

	// 6. Encode output entropy into BIP39 mnemonic
	outMnem, _ := bip39.NewMnemonic(outEnt)

	// 7. Create sleeve
	s := &Sleeve{
		mnemonic:  mnemonic,
		xxAddress: xxAddress,
		output:    outMnem,
	}
	return s, nil
}
